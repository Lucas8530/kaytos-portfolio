import e from"path";import t from"remark-mdx";import s from"remark-parse";import n from"unified";const o=["@typescript-eslint/parser","@babel/eslint-parser","babel-eslint","espree"],r=["JSXElement","JSXFragment"],i=e=>r.includes(e.type),l=e=>{if(e){if("string"==typeof e&&(e=require(e)),"object"==typeof e&&(e="parseForESLint"in e&&e.parseForESLint||"parse"in e&&e.parse),"function"!=typeof e)throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${e}`);return[e]}const t=[];for(const e of o)try{const s=require(e),n="parseForESLint"in s?s.parseForESLint:s.parse;n&&t.push(n)}catch(e){}return t},c=e=>{const t=e.start.offset,s=e.end.offset;return{range:[t,s],loc:e,start:t,end:s}},a=(e,t)=>"object"==typeof e&&e&&t.every((t=>t in e)),u=(e,t)=>{let s=0;const n=e.split("\n");for(let e=0;e<n.length;e++){const o=e+1,r=s+n[e].length;if(r>=t)return{line:o,column:t-s};s=r+1}},p=(e,t)=>{if(e&&"object"==typeof e)for(const s of Object.values(e))p(s,t);if(!a(e,["loc","range"]))return e;let{loc:{start:s,end:n},range:[o,r]}=e;const i=[o+=t.offset,r+=t.offset];return Object.assign(e,{start:o,end:r,range:i,loc:{start:{line:t.line+s.line,column:s.column+(1===s.line?t.column:0)},end:{line:t.line+n.line,column:n.column+(1===n.line?t.column:0)}}})},m=(...e)=>e.reduce(((e,t)=>(e.push(...Array.isArray(t)?t:null==t?[]:[t]),e)),[]),h=e=>e&&e[0],f=e=>e&&e[e.length-1],d="(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*"+("(?:[^\"'=<>`\\u0000-\\u0020]+|'[^']*'|\"[^\"]*\"|"+"{.*}".replace(".","[\0-ï¿¿]")+")")+")?)",x="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+d+"*\\s*>",g="<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>",b="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+d+"*\\s*\\/?>",y="\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e",_="(\x3c!---*)",v="(-*--\x3e)",E="(\x3c!---*)([\\s\\S]*?)(-*--\x3e)",j=new RegExp(`^(?:${x})$`),S=new RegExp(`^(?:${g})$`),w=new RegExp(`^(?:${x+"[^<]*"+g})$`),J=new RegExp(`^(?:${b})$`),N=new RegExp(`^(?:${y})$`),$=new RegExp("(\x3c!---*)([\\s\\S]*?)(-*--\x3e)"),L=new RegExp("(\x3c!---*)([\\s\\S]*?)(-*--\x3e)","g"),z=e=>j.test(e.trim()),T=e=>S.test(e.trim()),A=e=>N.test(e.trim()),F=e=>w.test(e.trim()),O=e=>J.test(e.trim());class k{constructor({code:e,enter:t}){this.code=e,this._enter=t}combineLeftJsxNodes(e,t){var s;const n=e[0].position.start,o=Object.assign({},f(e).position.end);return t&&(null===(s=t.position.indent)||void 0===s?void 0:s.length)>0&&(o.offset+=t.position.indent.reduce(((e,t,s)=>e+(s?t+1:0)),0)),{type:"jsx",data:e[0].data,value:this.code.slice(n.offset,o.offset),position:{start:n,end:o}}}combineJsxNodes(e,t){let s=0,n=!1;const o=[],{length:r}=e;return e.reduce(((e,i,l)=>{if("jsx"===i.type){const r=i.value;if(z(r))s++,n=!0,o.push(i);else{if(T(r))s--,o.push(i);else if(A(r)||O(r)||F(r))o.push(i);else{l||(s++,n=!0);try{o.push(...m(D.normalizeJsxNode(i,t)))}catch(e){if(!s){const{start:e}=i.position;throw Object.assign(new SyntaxError("unknown jsx node: "+JSON.stringify(r)),{lineNumber:e.line,column:e.column,index:e.offset})}o.push(i)}}if(!s){const s=o.findIndex((e=>"string"==typeof e.value&&z(e.value)));-1===s?n?e.push(this.combineLeftJsxNodes(o,t)):e.push(...o):e.push(...o.slice(0,s),this.combineLeftJsxNodes(o.slice(s),t)),o.length=0}}}else s?o.push(i):e.push(i);return l===r-1&&o.length>0&&e.push(this.combineLeftJsxNodes(o,t)),e}),[])}traverse(e,t){if(!e)return;let s=e.children;if(s){const t=e;s=e.children=this.combineJsxNodes(s,t);for(const e of s)this.traverse(e,t)}this._enter(e,t)}}const P=(e,t)=>new k(t).traverse(e),Z=n().use(s).freeze(),R=Z().use(t).freeze(),X=["body","comments","tokens"],C=["export","import","jsx"],H=["column","lineNumber"],M=[".mdx"],W=[".md"],q={comment:!0,ecmaFeatures:{jsx:!0},ecmaVersion:(new Date).getUTCFullYear(),sourceType:"module",tokens:!0,filePath:"__placeholder__.mdx",loc:!0,range:!0},I="<$>".length;class B{constructor(){this._options=q,this.parse=this.parse.bind(this),this.parseForESLint=this.parseForESLint.bind(this)}normalizeJsxNode(e,t,s=this._options){const n=e.value;if("jsx"!==e.type||A(n))return e;if($.exec(n)){const s=[],{position:{start:{line:o,column:r,offset:i}},data:l}=e;Object.assign(e,{data:Object.assign(Object.assign({},l),{jsxType:"JSXElementWithHTMLComments",comments:s,inline:!!t&&"root"!==t.type}),value:n.replace(L,((e,t,l,c,a)=>{const u=a+e.length,p=n.slice(0,a).split("\n"),m=n.slice(0,u).split("\n"),h=`{/${"*".repeat(t.length-2)}${l}${"*".repeat(c.length-2)}/}`,d=p.length-1,x=m.length-1;return s.push({fixed:h,loc:{start:{line:o+d,column:f(p).length+(d?0:r-1),offset:i+a},end:{line:o+x,column:f(m).length+(x?0:r-1),offset:i+u}},origin:e}),h}))})}return this._normalizeJsxNodes(e,s)}parse(e,t){return this.parseForESLint(e,t).ast}parseForESLint(t,s){const n=e.extname(s.filePath),o=M.concat(s.extensions||[]).includes(n),r=W.concat(s.markdownExtensions||[]).includes(n);if(!o&&!r)return this._eslintParse(t,s);const i=(o?R:Z).parse(t);return this._ast=Object.assign(Object.assign({},c(i.position)),{type:"Program",sourceType:s.sourceType||"module",body:[],comments:[],tokens:[]}),this._services={JSXElementsWithHTMLComments:[]},o&&P(i,{code:t,enter:(e,n)=>{if(C.includes(e.type))for(const o of m(this.normalizeJsxNode(e,n,s)))this._nodeToAst(t,o,s)}}),{ast:this._ast,services:this._services}}_eslintParse(e,t){let s,n;this._parsers&&t.parser===this._options.parser||(this._parsers=l(t.parser)),t.filePath&&this._options!==t&&Object.assign(this._options,t);for(const t of this._parsers)try{s=t(e,this._options);break}catch(e){n||(n=e)}if(!s&&n)throw n;return"ast"in s&&s.ast?s:{ast:s}}_normalizeJsxNodes(e,t){const s=e.value;let n;try{n=this._eslintParse(`<$>${s}</$>`,t).ast}catch(t){if(a(t,H)){const{position:{start:s}}=e;throw"index"in t?t.index+=s.offset-I:"pos"in t&&(t.pos+=s.offset-I),t.column=t.lineNumber>1?t.column:t.column+s.column-I,t.lineNumber+=s.line-1,t}return e}const{expression:o}=n.body[0];if(!i(o)||o.children.length<=1)return e;const{position:{start:{line:r,offset:l}},data:c}=e;return o.children.reduce(((e,t)=>{if(!i(t))return e;const{start:n,end:o,loc:{start:a,end:u}={start:{column:n,line:1},end:{column:o,line:1}},range:p=[n,o]}=t,m=r+a.line-1,h=r+u.line-1,f=p[0]-I,d=p[1]-I;return e.push({type:"jsx",data:e.length>0?null:c,value:s.slice(f,d),position:{start:{line:m,column:r===m?a.column-I:a.column,offset:l+f},end:{line:h,column:r===m?u.column-I:u.column,offset:l+d}}}),e}),[])}_nodeToAst(e,t,s){t.data&&"JSXElementWithHTMLComments"===t.data.jsxType&&this._services.JSXElementsWithHTMLComments.push(t);const n=t.value,{loc:o,start:r,end:i}=c(t.position);if(A(n)){const e=$.exec(n)[2];return void this._ast.comments.push({type:"Block",value:e,loc:o,range:[r,i]})}const l=o.start.line-1;let m;try{m=this._eslintParse(n,s).ast}catch(e){throw a(e,H)&&(e.index+=r,e.column=e.lineNumber>1?e.column:e.column+o.start.column,e.lineNumber+=l),e}const h={line:l,column:u(e,r).column,offset:r};for(const e of X)this._ast[e].push(...m[e].map((e=>p(e,h))))}}const D=new B,{parse:U,parseForESLint:V}=D;export{X as AST_PROPS,S as CLOSE_TAG_REGEX,$ as COMMENT_CONTENT_REGEX,L as COMMENT_CONTENT_REGEX_GLOBAL,N as COMMENT_REGEX,M as DEFAULT_EXTENSIONS,q as DEFAULT_PARSER_OPTIONS,C as ES_NODE_TYPES,o as FALLBACK_PARSERS,r as JSX_TYPES,H as LOC_ERROR_PROPERTIES,W as MARKDOWN_EXTENSIONS,w as OPEN_CLOSE_TAG_REGEX,j as OPEN_TAG_REGEX,B as Parser,J as SELF_CLOSING_TAG_REGEX,k as Traverse,m as arrayify,g as closeTag,y as comment,v as commentClose,E as commentContent,_ as commentOpen,h as first,u as getPositionAt,a as hasProperties,T as isCloseTag,A as isComment,i as isJsxNode,F as isOpenCloseTag,z as isOpenTag,O as isSelfClosingTag,f as last,Z as mdProcessor,R as mdxProcessor,l as normalizeParser,c as normalizePosition,x as openTag,U as parse,V as parseForESLint,D as parser,p as restoreNodeLocation,b as selfClosingTag,P as traverse};
