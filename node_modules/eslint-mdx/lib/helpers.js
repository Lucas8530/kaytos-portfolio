/// <reference path="../typings.d.ts" />
export const FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    '@babel/eslint-parser',
    'babel-eslint',
    'espree',
];
export const JSX_TYPES = ['JSXElement', 'JSXFragment'];
export const isJsxNode = (node) => JSX_TYPES.includes(node.type);
// eslint-disable-next-line sonarjs/cognitive-complexity
export const normalizeParser = (parser) => {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${parser}`);
        }
        return [parser];
    }
    const parsers = [];
    // try to load FALLBACK_PARSERS automatically
    for (const fallback of FALLBACK_PARSERS) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            const fallbackParser = require(fallback);
            /* istanbul ignore next */
            const parserFn = 'parseForESLint' in fallbackParser
                ? // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parseForESLint
                : // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.push(parserFn);
            }
        }
        catch (_a) { }
    }
    return parsers;
};
export const normalizePosition = (loc) => {
    const start = loc.start.offset;
    const end = loc.end.offset;
    return {
        range: [start, end],
        loc,
        start,
        end,
    };
};
export const hasProperties = (obj, properties) => typeof obj === 'object' &&
    obj &&
    properties.every(property => property in obj);
// fix #292
export const getPositionAt = (code, offset) => {
    let currOffset = 0;
    const lines = code.split('\n');
    // eslint-disable-next-line unicorn/no-for-loop
    for (let index = 0; index < lines.length; index++) {
        const line = index + 1;
        const nextOffset = currOffset + lines[index].length;
        if (nextOffset >= offset) {
            return {
                line,
                column: offset - currOffset,
            };
        }
        currOffset = nextOffset + 1; // add a line break `\n` offset
    }
};
export const restoreNodeLocation = (node, point) => {
    if (node && typeof node === 'object') {
        for (const value of Object.values(node)) {
            restoreNodeLocation(value, point);
        }
    }
    if (!hasProperties(node, ['loc', 'range'])) {
        return node;
    }
    let { loc: { start: startLoc, end: endLoc }, range: [start, end], } = node;
    const range = [(start += point.offset), (end += point.offset)];
    return Object.assign(node, {
        start,
        end,
        range,
        loc: {
            start: {
                line: point.line + startLoc.line,
                column: startLoc.column + (startLoc.line === 1 ? point.column : 0),
            },
            end: {
                line: point.line + endLoc.line,
                column: endLoc.column + (endLoc.line === 1 ? point.column : 0),
            },
        },
    });
};
export const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
export const first = (items) => items && items[0];
export const last = (items) => items && items[items.length - 1];
//# sourceMappingURL=helpers.js.map